import os
import ssl
from typing import Dict, Tuple, Optional, List
from datetime import datetime, timezone, timedelta

import asyncpg
from dotenv import load_dotenv

from aiogram import Bot, Dispatcher, Router, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.filters import CommandStart, StateFilter
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.types import (
    Message, CallbackQuery,
    ReplyKeyboardMarkup, KeyboardButton,
    InlineKeyboardMarkup, InlineKeyboardButton,
    InputMediaPhoto,
)

# ========= ENV =========
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN")
DB_URL = os.getenv("DATABASE_URL")
assert BOT_TOKEN, "‚ùå BOT_TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ .env"
assert DB_URL, "‚ùå DATABASE_URL –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ .env"

# ========= BOT / DP / ROUTER =========
bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()
dp.include_router(router)

# ========= DB POOL =========
pool: Optional[asyncpg.Pool] = None

def _make_ssl_context() -> ssl.SSLContext:
    base = os.path.dirname(__file__)
    for name in ("supabase-ca.crt", "prod-ca-2021.crt", "supabase-ca.pem"):
        path = os.path.join(base, name)
        if os.path.exists(path):
            print(f"SSL: using CA file {name}")
            return ssl.create_default_context(cafile=path)
    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE
    print("SSL: verification DISABLED (dev fallback). Put supabase-ca.crt next to bot.py to enable verification.")
    return ctx

async def open_db_pool():
    global pool
    ssl_ctx = _make_ssl_context()
    pool = await asyncpg.create_pool(dsn=DB_URL, min_size=1, max_size=5, ssl=ssl_ctx)
    async with pool.acquire() as con:
        ver = await con.fetchval("select version()")
        print("DB pool ready ‚úÖ", ver)

        # PostGIS (–µ—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–∞–≤–∞)
        try:
            await con.execute("CREATE EXTENSION IF NOT EXISTS postgis;")
        except Exception:
            pass

        # app_user
        await con.execute(
            """
            CREATE TABLE IF NOT EXISTS app_user(
                id BIGSERIAL PRIMARY KEY,
                tg_user_id BIGINT UNIQUE NOT NULL,
                username TEXT,
                created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                lang TEXT
            );
            CREATE INDEX IF NOT EXISTS idx_app_user_lang ON app_user(lang);
            """
        )

        # poi.created_at
        await con.execute(
            """
            DO $$
            BEGIN
              IF to_regclass('public.poi') IS NOT NULL THEN
                IF NOT EXISTS (
                  SELECT 1 FROM information_schema.columns
                  WHERE table_name='poi' AND column_name='created_at'
                ) THEN
                  EXECUTE 'ALTER TABLE poi ADD COLUMN created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()';
                END IF;
              END IF;
            END
            $$;
            """
        )

        # poi_confirmation.created_at
        await con.execute(
            """
            DO $$
            BEGIN
              IF to_regclass('public.poi_confirmation') IS NOT NULL THEN
                IF NOT EXISTS (
                  SELECT 1 FROM information_schema.columns
                  WHERE table_name='poi_confirmation' AND column_name='created_at'
                ) THEN
                  EXECUTE 'ALTER TABLE poi_confirmation ADD COLUMN created_at TIMESTAMPTZ DEFAULT NOW()';
                  EXECUTE 'UPDATE poi_confirmation SET created_at = NOW() WHERE created_at IS NULL';
                  EXECUTE 'ALTER TABLE poi_confirmation ALTER COLUMN created_at SET NOT NULL';
                END IF;
                IF NOT EXISTS (
                  SELECT 1 FROM pg_indexes WHERE schemaname='public' AND indexname='uq_poi_confirmation_poi_user'
                ) THEN
                  EXECUTE 'CREATE UNIQUE INDEX uq_poi_confirmation_poi_user ON poi_confirmation(poi_id, user_id)';
                END IF;
                IF NOT EXISTS (
                  SELECT 1 FROM pg_indexes WHERE schemaname='public' AND indexname='idx_poi_confirmation_created'
                ) THEN
                  EXECUTE 'CREATE INDEX idx_poi_confirmation_created ON poi_confirmation(created_at)';
                END IF;
              END IF;
            END
            $$;
            """
        )

        # –ò–Ω–¥–µ–∫—Å –ø–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è–º
        await con.execute(
            """
            CREATE INDEX IF NOT EXISTS idx_poi_confirmation_poi_id
            ON poi_confirmation(poi_id);
            """
        )

        # –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è —Ñ–æ—Ç–æ
        await con.execute(
            """
            CREATE TABLE IF NOT EXISTS poi_photo (
                id BIGSERIAL PRIMARY KEY,
                poi_id BIGINT NOT NULL REFERENCES poi(id) ON DELETE CASCADE,
                file_id TEXT NOT NULL,
                user_id BIGINT REFERENCES app_user(id) ON DELETE SET NULL,
                created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
            );
            CREATE INDEX IF NOT EXISTS idx_poi_photo_poi_id ON poi_photo(poi_id);
            CREATE INDEX IF NOT EXISTS idx_poi_photo_poi_created ON poi_photo(poi_id, created_at DESC);
            """
        )

        # –ü–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –≥–µ–æ–∑–æ–Ω—ã (+ last_refreshed_at)
        await con.execute(
            """
            CREATE TABLE IF NOT EXISTS subscriptions (
                id BIGSERIAL PRIMARY KEY,
                tg_user_id BIGINT NOT NULL,
                center geography(Point,4326) NOT NULL,
                radius_m DOUBLE PRECISION NOT NULL CHECK (radius_m > 0),
                is_active BOOLEAN NOT NULL DEFAULT TRUE,
                created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                last_refreshed_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
            );
            DO $$
            BEGIN
              IF NOT EXISTS (
                SELECT 1 FROM information_schema.columns
                WHERE table_name='subscriptions' AND column_name='last_refreshed_at'
              ) THEN
                EXECUTE 'ALTER TABLE subscriptions ADD COLUMN last_refreshed_at TIMESTAMPTZ NOT NULL DEFAULT NOW()';
              END IF;
            END$$;
            CREATE INDEX IF NOT EXISTS idx_subscriptions_user ON subscriptions(tg_user_id);
            CREATE INDEX IF NOT EXISTS idx_subscriptions_active ON subscriptions(is_active);
            CREATE INDEX IF NOT EXISTS idx_subscriptions_center ON subscriptions USING GIST (geography(center));
            CREATE INDEX IF NOT EXISTS idx_subscriptions_refresh ON subscriptions(last_refreshed_at);
            """
        )

async def close_db_pool():
    global pool
    if pool is not None:
        await pool.close()
        pool = None
        print("DB pool closed.")

dp.startup.register(open_db_pool)
dp.shutdown.register(close_db_pool)

# ========= HELPERS / CONSTANTS =========
CONFIRM_RADIUS_MI = 0.5
FRESH_LOCATION_MINUTES = 10
SUBSCRIPTION_TTL_HOURS = 12
ADD_LIMIT_COUNT = 2
ADD_LIMIT_WINDOW_H = 12

LANGS = {
    "ru": "–†—É—Å—Å–∫–∏–π",
    "en": "English",
    "es": "Espa√±ol (LatAm)",
    "ar": "ÿßŸÑÿπÿ±ÿ®Ÿäÿ©",
    "hi": "‡§π‡§ø‡§®‡•ç‡§¶‡•Ä",
}
DEFAULT_LANG = "en"

# ===== –õ–æ–∫–∞–ª–∏–∑–∞—Ü–∏—è =====
STRINGS = {
    "start_intro": {
        "ru": (
            """–ü—Ä–∏–≤–µ—Ç! –Ø –ø–æ–º–æ–≥—É –Ω–∞–π—Ç–∏ —Ç–µ–±–µ –∞–¥—Ä–µ—Å–∞ –≥–¥–µ –ø—Ä–æ—Ö–æ–¥—è—Ç —Ä–µ–π–¥—ã ICE —Ä—è–¥–æ–º –∏ –¥–æ–±–∞–≤–∏—Ç—å –∞–¥—Ä–µ—Å–∞ ICE –µ—Å–ª–∏ –≤—ã —É–≤–∏–¥–∏—Ç–µ –≥–¥–µ-—Ç–æ –ø–æ–±–ª–∏–∑–æ—Å—Ç–∏ —á—Ç–æ–±—ã –∏ –¥—Ä—É–≥–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –º–æ–≥–ª–∏ –∏–∑–±–µ–≥–∞—Ç—å –Ω–µ–æ–±–æ—Å–Ω–æ–≤–∞–Ω–Ω—ã—Ö –∑–∞–¥–µ—Ä–∂–∞–Ω–∏–π —Å–æ —Å—Ç–æ—Ä–æ–Ω—ã —Å–ª—É–∂–± ICE.
        –ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è:
        ‚Ä¢ –û—Ç–ø—Ä–∞–≤—å —Å–≤–æ—é –ª–æ–∫–∞—Ü–∏—é ‚Äî –≤—ã–±–µ—Ä–∏ —Ä–∞–¥–∏—É—Å 10/50/100 mi –∏ —É–≤–∏–¥–∏—à—å –±–ª–∏–∂–∞–π—à–∏–µ —Ç–æ—á–∫–∏.
        ‚Ä¢ –ù–∞–∂–º–∏ ¬´‚ûï –î–æ–±–∞–≤–∏—Ç—å —Ç–æ—á–∫—É¬ª, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é. –ú–æ–∂–Ω–æ –ø—Ä–∏–ª–æ–∂–∏—Ç—å —Ñ–æ—Ç–æ –∏ –∫–æ—Ä–æ—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ (–ø–æ –∂–µ–ª–∞–Ω–∏—é).
        ‚Ä¢ –ù–∞–∂–º–∏ ¬´üì° –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ¬ª, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∞—Ç—å –Ω–æ–≤—ã–µ —Ç–æ—á–∫–∏ —Ä—è–¥–æ–º. –¶–µ–Ω—Ç—Ä –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è ‚Äî —Ç–≤–æ—è –ø–æ—Å–ª–µ–¥–Ω—è—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –ª–æ–∫–∞—Ü–∏—è.
        ‚Ä¢ –ú–æ–∂–µ—à—å –≤–∫–ª—é—á–∏—Ç—å Live-–ª–æ–∫–∞—Ü–∏—é –≤ Telegram: –ø–æ–∫–∞ –æ–Ω–∞ –∞–∫—Ç–∏–≤–Ω–∞, –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.
        ‚Ä¢ –ù–∞—à—ë–ª —Ç–æ—á–∫—É –Ω–∞ –º–µ—Å—Ç–µ ‚Äî –Ω–∞–∂–º–∏ ¬´Confirm point¬ª, —á—Ç–æ–±—ã –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å (–Ω—É–∂–Ω–∞ —Å–≤–µ–∂–∞—è –ª–æ–∫–∞—Ü–∏—è ‚â§10 –º–∏–Ω –∏ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ ‚â§0.5 mi).

    –ü—Ä–∞–≤–∏–ª–∞ –∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:
    ‚Ä¢ –°–≤–µ–∂–µ—Å—Ç—å —Ç–æ—á–µ–∫ ‚Äî 12 —á–∞—Å–æ–≤: –≤ —Å–ø–∏—Å–∫–µ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç—Å—è –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ/–ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã–µ –∑–∞ —ç—Ç–æ –≤—Ä–µ–º—è.
    ‚Ä¢ –õ–∏–º–∏—Ç –Ω–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ: –Ω–µ –±–æ–ª–µ–µ 2 —Ç–æ—á–µ–∫ –∑–∞ 12 —á–∞—Å–æ–≤ –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    ‚Ä¢ –Ø–∑—ã–∫ –º–æ–∂–Ω–æ —Å–º–µ–Ω–∏—Ç—å —á–µ—Ä–µ–∑ ¬´Language¬ª –∏–ª–∏ –∫–æ–º–∞–Ω–¥—É /lang.

    –£–¥–∞—á–∏ –∏ —Å–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–º–æ—â—å!\n\n"""

        
    "‚Ä¢ –ü—Ä–∏—à–ª–∏ –ª–æ–∫–∞—Ü–∏—é ‚Üí –≤—ã–±–µ—Ä–∏ —Ä–∞–¥–∏—É—Å 10/50/100 mi\n"
    "‚Ä¢ –ù–∞–∂–º–∏ ¬´‚ûï –î–æ–±–∞–≤–∏—Ç—å —Ç–æ—á–∫—É¬ª, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é\n"
    "‚Ä¢ –ù–∞–∂–º–∏ ¬´üì° –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ¬ª, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∞—Ç—å –Ω–æ–≤—ã–µ —Ç–æ—á–∫–∏ —Ä—è–¥–æ–º\n\n"
        ),
        "en": (
            """Hi! I'll help you find nearby ICE raid addresses and add them if you see them nearby so other users can avoid unwarranted detentions by ICE.
            How it works:
‚Ä¢ Send your location ‚Äî pick a 10/50/100 mi radius to see nearby spots.
‚Ä¢ Tap ‚Äú‚ûï Add spot‚Äù to create a new one. Photos and a short description are optional.
‚Ä¢ Tap ‚Äúüì° Tracking‚Äù to get alerts about new spots near you. The center is your last sent location.
‚Ä¢ You can enable Telegram Live Location: while it‚Äôs on, tracking auto-refreshes.
‚Ä¢ At the place? Tap ‚ÄúConfirm point‚Äù to verify it (requires a fresh location ‚â§10 min and distance ‚â§0.5 mi).

Rules & limits:
‚Ä¢ Freshness window: 12 hours (only spots added/confirmed within this period are shown).
‚Ä¢ Add limit: up to 2 spots per 12 hours per user.
‚Ä¢ Change language via ‚ÄúLanguage‚Äù button or /lang.

Thanks for contributing!\n\n"""


            "‚Ä¢ Send your location ‚Üí choose 10/50/100 mi radius\n"
            "‚Ä¢ Tap ‚Äú‚ûï Add spot‚Äù to create a new one\n"
            "‚Ä¢ Tap ‚Äúüì° Tracking‚Äù to get nearby alerts\n\n"
        ),
        "es": (
            """¬°Hola! Te ayudar√© a encontrar direcciones de redadas de ICE cercanas y las agregar√© si las ves cerca para que otros usuarios puedan evitar detenciones injustificadas por parte de ICE. 
            üìå C√≥mo usar:
‚Ä¢ üìç Env√≠a tu ubicaci√≥n ‚Äî elige un radio de 10/50/100 millas para ver puntos cercanos.  
‚Ä¢ ‚ûï Toca ‚ÄúAgregar punto‚Äù para crear uno nuevo. Puedes a√±adir fotos y una breve descripci√≥n.  
‚Ä¢ üì° Toca ‚ÄúRastreo‚Äù para recibir alertas de nuevos puntos cerca de ti. El centro es tu √∫ltima ubicaci√≥n enviada.  
‚Ä¢ Puedes activar la Ubicaci√≥n en vivo de Telegram: mientras est√© activa, el rastreo se actualiza autom√°ticamente.  
‚Ä¢ ¬øEst√°s en el lugar? Toca ‚ÄúConfirmar punto‚Äù para verificarlo (ubicaci√≥n fresca ‚â§10 min y ‚â§0.5 mi).

‚ö†Ô∏è Reglas:
‚Ä¢ Los puntos son v√°lidos por 12 horas.  
‚Ä¢ L√≠mite: 2 puntos cada 12 horas.  
‚Ä¢ Cambia el idioma con ‚ÄúIdioma‚Äù o /lang.\n\n"""


            "‚Ä¢ Env√≠a tu ubicaci√≥n ‚Üí elige radio 10/50/100 mi\n"
            "‚Ä¢ Toca ‚Äú‚ûï Agregar punto‚Äù para crear uno nuevo\n"
            "‚Ä¢ Toca ‚Äúüì° Rastreo‚Äù para recibir alertas cercanas\n\n"
        ),
        "ar": (
            """ŸÖÿ±ÿ≠ÿ®ÿßŸã! ÿ≥ÿ£ÿ≥ÿßÿπÿØŸÉ ŸÅŸä ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿπŸÜÿßŸàŸäŸÜ ŸÖÿØÿßŸáŸÖÿßÿ™ ÿØÿßÿ¶ÿ±ÿ© ÿßŸÑŸáÿ¨ÿ±ÿ© ŸàÿßŸÑÿ¨ŸÖÿßÿ±ŸÉ ÿßŸÑÿ£ŸÖÿ±ŸäŸÉŸäÿ© (ICE) ÿßŸÑŸÇÿ±Ÿäÿ®ÿ© ŸÖŸÜŸÉÿå Ÿàÿ≥ÿ£ÿ∂ŸäŸÅŸáÿß ÿ•ÿ∞ÿß Ÿàÿ¨ÿØÿ™Ÿáÿßÿå ŸÑŸäÿ™ŸÖŸÉŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸàŸÜ ÿßŸÑÿ¢ÿÆÿ±ŸàŸÜ ŸÖŸÜ ÿ™ÿ¨ŸÜÿ® ÿßŸÑÿßÿ≠ÿ™ÿ¨ÿßÿ≤ÿßÿ™ ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ®ÿ±ÿ±ÿ© ŸÖŸÜ ŸÇŸêÿ®ŸÑ ÿØÿßÿ¶ÿ±ÿ© ÿßŸÑŸáÿ¨ÿ±ÿ© ŸàÿßŸÑÿ¨ŸÖÿßÿ±ŸÉ ÿßŸÑÿ£ŸÖÿ±ŸäŸÉŸäÿ© (ICE).
            üìå ŸÉŸäŸÅŸäÿ© ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ:
‚Ä¢ üìç ÿ£ÿ±ÿ≥ŸÑ ŸÖŸàŸÇÿπŸÉ ‚Äî ÿßÿÆÿ™ÿ± ŸÜÿµŸÅ ŸÇÿ∑ÿ± 10 ÿ£Ÿà 50 ÿ£Ÿà 100 ŸÖŸäŸÑ ŸÑÿπÿ±ÿ∂ ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑŸÇÿ±Ÿäÿ®ÿ©.  
‚Ä¢ ‚ûï ÿßÿ∂ÿ∫ÿ∑ ‚Äúÿ•ÿ∂ÿßŸÅÿ© ŸÜŸÇÿ∑ÿ©‚Äù ŸÑÿ•ŸÜÿ¥ÿßÿ° ŸÜŸÇÿ∑ÿ© ÿ¨ÿØŸäÿØÿ©. ŸäŸÖŸÉŸÜŸÉ ÿ•ÿ±ŸÅÿßŸÇ ÿµŸàÿ± ŸàŸàÿµŸÅ ŸÇÿµŸäÿ± ÿßÿÆÿ™Ÿäÿßÿ±Ÿä.  
‚Ä¢ üì° ÿßÿ∂ÿ∫ÿ∑ ‚ÄúÿßŸÑÿ™ÿ™ÿ®ÿπ‚Äù ŸÑÿ™ŸÑŸÇŸä ÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿ≠ŸàŸÑ ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑÿ¨ÿØŸäÿØÿ© ÿ®ÿßŸÑŸÇÿ±ÿ® ŸÖŸÜŸÉ. ÿßŸÑŸÖÿ±ŸÉÿ≤ ŸáŸà ÿ¢ÿÆÿ± ŸÖŸàŸÇÿπ ÿ£ÿ±ÿ≥ŸÑÿ™Ÿá.  
‚Ä¢ ŸäŸÖŸÉŸÜŸÉ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ± ŸÅŸä ÿ™ŸäŸÑŸäÿ¨ÿ±ÿßŸÖ ‚Äî ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ¥ÿ∫ŸäŸÑŸáÿå Ÿäÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ÿ™ÿ®ÿπ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß.  
‚Ä¢ ŸÅŸä ÿßŸÑŸÖŸàŸÇÿπÿü ÿßÿ∂ÿ∫ÿ∑ ‚Äúÿ™ÿ£ŸÉŸäÿØ ÿßŸÑŸÜŸÇÿ∑ÿ©‚Äù ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜŸáÿß (ŸÖŸàŸÇÿπ ÿ≠ÿØŸäÿ´ ‚â§10 ÿØŸÇÿßÿ¶ŸÇ ŸàŸÖÿ≥ÿßŸÅÿ© ‚â§0.5 ŸÖŸäŸÑ).

‚ö†Ô∏è ÿßŸÑŸÇŸàÿßÿπÿØ:
‚Ä¢ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑŸÜŸÇÿßÿ∑ 12 ÿ≥ÿßÿπÿ©.  
‚Ä¢ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ: ŸÜŸÇÿ∑ÿ™ÿßŸÜ ŸÉŸÑ 12 ÿ≥ÿßÿπÿ©.  
‚Ä¢ ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑŸÑÿ∫ÿ© ŸÖŸÜ ÿ≤ÿ± ‚ÄúÿßŸÑŸÑÿ∫ÿ©‚Äù ÿ£Ÿà ÿßŸÑÿ£ŸÖÿ± /lang.\n\n"""


            "‚Ä¢ ÿ£ÿ±ÿ≥ŸÑ ŸÖŸàŸÇÿπŸÉ ‚Üí ÿßÿÆÿ™ÿ± ŸÜÿµŸÅ ŸÇÿ∑ÿ± 10/50/100 ŸÖŸäŸÑ\n"
            "‚Ä¢ ÿßÿ∂ÿ∫ÿ∑ ‚Äú‚ûï ÿ•ÿ∂ÿßŸÅÿ© ŸÜŸÇÿ∑ÿ©‚Äù ŸÑÿ•ŸÜÿ¥ÿßÿ° ŸÜŸÇÿ∑ÿ© ÿ¨ÿØŸäÿØÿ©\n"
            "‚Ä¢ ÿßÿ∂ÿ∫ÿ∑ ‚Äúüì° ÿßŸÑÿ™ÿ™ÿ®ÿπ‚Äù ŸÑÿ™ŸÑŸÇŸä ÿßŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿßŸÑŸÇÿ±Ÿäÿ®ÿ©\n\n"
        ),
        "hi": (
            """‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•á ‡§Ü‡§∏-‡§™‡§æ‡§∏ ‡§ï‡•á ICE ‡§∞‡•á‡§° ‡§™‡§§‡•á ‡§¢‡•Ç‡§Å‡§¢‡§º‡§®‡•á ‡§Æ‡•á‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡•Ç‡§Å‡§ó‡§æ ‡§î‡§∞ ‡§Ö‡§ó‡§∞ ‡§Ü‡§™‡§ï‡•ã ‡§Ü‡§∏-‡§™‡§æ‡§∏ ‡§ï‡•ã‡§à ‡§™‡§§‡§æ ‡§¶‡§ø‡§ñ‡•á ‡§§‡•ã ‡§â‡§∏‡•á ‡§µ‡§π‡§æ‡§Å ‡§ú‡•ã‡§°‡§º ‡§¶‡•Ç‡§Å‡§ó‡§æ ‡§§‡§æ‡§ï‡§ø ‡§¶‡•Ç‡§∏‡§∞‡•á ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ICE ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§Ö‡§®‡•Å‡§ö‡§ø‡§§ ‡§π‡§ø‡§∞‡§æ‡§∏‡§§ ‡§∏‡•á ‡§¨‡§ö ‡§∏‡§ï‡•á‡§Ç‡•§
            üìå ‡§ï‡•à‡§∏‡•á ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§∞‡•á‡§Ç:
‚Ä¢ üìç ‡§Ö‡§™‡§®‡•Ä ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§≠‡•á‡§ú‡•á‡§Ç ‚Äî 10/50/100 ‡§Æ‡•Ä‡§≤ ‡§ï‡§æ ‡§∞‡•á‡§°‡§ø‡§Ø‡§∏ ‡§ö‡•Å‡§®‡•á‡§Ç ‡§î‡§∞ ‡§®‡§ú‡§º‡§¶‡•Ä‡§ï‡•Ä ‡§™‡•â‡§á‡§Ç‡§ü ‡§¶‡•á‡§ñ‡•á‡§Ç‡•§  
‚Ä¢ ‚ûï ‚Äú‡§™‡•â‡§á‡§Ç‡§ü ‡§ú‡•ã‡§°‡§º‡•á‡§Ç‚Äù ‡§¶‡§¨‡§æ‡§è‡§Å ‡§î‡§∞ ‡§®‡§Ø‡§æ ‡§™‡•â‡§á‡§Ç‡§ü ‡§¨‡§®‡§æ‡§è‡§Ç‡•§ ‡§Ü‡§™ ‡§´‡•ã‡§ü‡•ã ‡§î‡§∞ ‡§õ‡•ã‡§ü‡§æ ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§ú‡•ã‡§°‡§º ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§  
‚Ä¢ üì° ‚Äú‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó‚Äù ‡§¶‡§¨‡§æ‡§è‡§Å ‡§§‡§æ‡§ï‡§ø ‡§Ü‡§∏-‡§™‡§æ‡§∏ ‡§ï‡•á ‡§®‡§è ‡§™‡•â‡§á‡§Ç‡§ü ‡§ï‡•á ‡§Ö‡§≤‡§∞‡•ç‡§ü ‡§Æ‡§ø‡§≤‡•á‡§Ç‡•§ ‡§∏‡•á‡§Ç‡§ü‡§∞ ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§ñ‡§ø‡§∞‡•Ä ‡§≠‡•á‡§ú‡•Ä ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§π‡•à‡•§  
‚Ä¢ Telegram ‡§ï‡•Ä Live Location ‡§ö‡§æ‡§≤‡•Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç ‚Äî ‡§ú‡§¨ ‡§§‡§ï ‡§ö‡§æ‡§≤‡•Ç ‡§π‡•à, ‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó ‡§Ö‡§™‡§®‡•á-‡§Ü‡§™ ‡§Ö‡§™‡§°‡•á‡§ü ‡§π‡•ã‡§§‡•Ä ‡§∞‡§π‡•á‡§ó‡•Ä‡•§  
‚Ä¢ ‡§ú‡§ó‡§π ‡§™‡§∞ ‡§π‡•à‡§Ç? ‚Äú‡§™‡•â‡§á‡§Ç‡§ü ‡§ï‡§®‡•ç‡§´‡§∞‡•ç‡§Æ ‡§ï‡§∞‡•á‡§Ç‚Äù ‡§¶‡§¨‡§æ‡§è‡§Å (‡§§‡§æ‡§ú‡§º‡§æ ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‚â§10 ‡§Æ‡§ø‡§®‡§ü ‡§î‡§∞ ‡§¶‡•Ç‡§∞‡•Ä ‚â§0.5 ‡§Æ‡•Ä‡§≤ ‡§π‡•ã‡§®‡•Ä ‡§ö‡§æ‡§π‡§ø‡§è)‡•§

‚ö†Ô∏è ‡§®‡§ø‡§Ø‡§Æ:
‚Ä¢ ‡§™‡•â‡§á‡§Ç‡§ü 12 ‡§ò‡§Ç‡§ü‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§µ‡•à‡§ß ‡§∞‡§π‡§§‡•á ‡§π‡•à‡§Ç‡•§  
‚Ä¢ 12 ‡§ò‡§Ç‡§ü‡•á ‡§Æ‡•á‡§Ç ‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ 2 ‡§™‡•â‡§á‡§Ç‡§ü ‡§ú‡•ã‡§°‡§º‡•á ‡§ú‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§  
‚Ä¢ ‡§≠‡§æ‡§∑‡§æ ‡§¨‡§¶‡§≤‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‚Äú‡§≠‡§æ‡§∑‡§æ‚Äù ‡§¨‡§ü‡§® ‡§Ø‡§æ /lang ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§∞‡•á‡§Ç\n\n"""


            "‚Ä¢ ‡§Ö‡§™‡§®‡•Ä ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§≠‡•á‡§ú‡•á‡§Ç ‚Üí 10/50/100 ‡§Æ‡•Ä‡§≤ ‡§ï‡§æ ‡§∞‡•á‡§°‡§ø‡§Ø‡§∏ ‡§ö‡•Å‡§®‡•á‡§Ç\n"
            "‚Ä¢ ‚Äú‚ûï ‡§™‡•â‡§á‡§Ç‡§ü ‡§ú‡•ã‡§°‡§º‡•á‡§Ç‚Äù ‡§¶‡§¨‡§æ‡§è‡§Å ‡§®‡§Ø‡§æ ‡§¨‡§®‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è\n"
            "‚Ä¢ ‚Äúüì° ‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó‚Äù ‡§¶‡§¨‡§æ‡§è‡§Å ‡§™‡§æ‡§∏ ‡§ï‡•á ‡§Ö‡§≤‡§∞‡•ç‡§ü ‡§™‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è\n\n"
        ),
    },
    "subscription_badge": {"ru": "–ü–æ–¥–ø–∏—Å–∫–∞","en": "Subscription","es":"Suscripci√≥n","ar":"ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ","hi":"‡§∏‡§¶‡§∏‡•ç‡§Ø‡§§‡§æ"},
    "already_subscribed": {"ru":"–û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ —É–∂–µ –≤–∫–ª—é—á–µ–Ω–æ.","en":"Tracking is already ON.","es":"El rastreo ya est√° ACTIVADO.","ar":"ÿßŸÑÿ™ÿ™ÿ®ÿπ ŸÖŸèŸÅÿπŸëŸéŸÑ ÿ®ÿßŸÑŸÅÿπŸÑ.","hi":"‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§ö‡§æ‡§≤‡•Ç ‡§π‡•à‡•§"},
    "send_location_first": {"ru":"–°–Ω–∞—á–∞–ª–∞ –ø—Ä–∏—à–ª–∏ —Ç–µ–∫—É—â—É—é –ª–æ–∫–∞—Ü–∏—é:","en":"Send your current location first:","es":"Primero env√≠a tu ubicaci√≥n actual:","ar":"ÿ£ÿ±ÿ≥ŸÑ ŸÖŸàŸÇÿπŸÉ ÿßŸÑÿ≠ÿßŸÑŸä ÿ£ŸàŸÑÿßŸã:","hi":"‡§™‡§π‡§≤‡•á ‡§Ö‡§™‡§®‡•Ä ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§≠‡•á‡§ú‡•á‡§Ç:"},
    "location_saved": {
        "ru":"‚úÖ –õ–æ–∫–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: <b>{lat:.5f}, {lon:.5f}</b>\n–í—ã–±–µ—Ä–∏ —Ä–∞–¥–∏—É—Å:",
        "en":"‚úÖ Location saved: <b>{lat:.5f}, {lon:.5f}</b>\nChoose a radius:",
        "es":"‚úÖ Ubicaci√≥n guardada: <b>{lat:.5f}, {lon:.5f}</b>\nElige un radio:",
        "ar":"‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸàŸÇÿπ: <b>{lat:.5f}, {lon:.5f}</b>\nÿßÿÆÿ™ÿ± ŸÜÿµŸÅ ÿßŸÑŸÇÿ∑ÿ±:",
        "hi":"‚úÖ ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§∏‡•á‡§µ ‡§π‡•ã ‡§ó‡§à: <b>{lat:.5f}, {lon:.5f}</b>\n‡§∞‡•á‡§°‡§ø‡§Ø‡§∏ ‡§ö‡•Å‡§®‡•á‡§Ç:",
    },
    "no_points_in_radius": {
        "ru":"–í —Ä–∞–¥–∏—É—Å–µ {miles} mi –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç–æ—á–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ (—Ñ–∏–ª—å—Ç—Ä 12 —á–∞—Å–æ–≤).",
        "en":"No active points found within {miles} mi (12-hour filter).",
        "es":"No se encontraron puntos activos dentro de {miles} mi (filtro de 12 horas).",
        "ar":"ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÜŸÇÿßÿ∑ ŸÜÿ¥ÿ∑ÿ© ÿ∂ŸÖŸÜ {miles} ŸÖŸäŸÑ (ŸÖÿ±ÿ¥ÿ≠ 12 ÿ≥ÿßÿπÿ©).",
        "hi":"{miles} ‡§Æ‡•Ä‡§≤ ‡§ï‡•á ‡§≠‡•Ä‡§§‡§∞ ‡§ï‡•ã‡§à ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§™‡•â‡§á‡§Ç‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ (12-‡§ò‡§Ç‡§ü‡•á ‡§´‡§º‡§ø‡§≤‡•ç‡§ü‡§∞)‡•§",
    },
    "back_to_start": {"ru":"‚Ü©Ô∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –Ω–∞—á–∞–ª–æ: –Ω–∞–∂–º–∏ /start","en":"‚Ü©Ô∏è Back to start: type /start","es":"‚Ü©Ô∏è Volver al inicio: escribe /start","ar":"‚Ü©Ô∏è ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ®ÿØÿßŸäÿ©: ÿßŸÉÿ™ÿ® /start","hi":"‚Ü©Ô∏è ‡§∂‡•Å‡§∞‡•Ç ‡§™‡§∞ ‡§≤‡•å‡§ü‡•á‡§Ç: /start ‡§≤‡§ø‡§ñ‡•á‡§Ç"},
    "confirm_button": {"ru":"–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —Ç–æ—á–∫—É","en":"Confirm point","es":"Confirmar punto","ar":"ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑŸÜŸÇÿ∑ÿ©","hi":"‡§™‡•â‡§á‡§Ç‡§ü ‡§ï‡§®‡•ç‡§´‡§∞‡•ç‡§Æ ‡§ï‡§∞‡•á‡§Ç"},
    "choose_category": {"ru":"–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:","en":"Choose a category:","es":"Elige una categor√≠a:","ar":"ÿßÿÆÿ™ÿ± ŸÅÿ¶ÿ©:","hi":"‡§∂‡•ç‡§∞‡•á‡§£‡•Ä ‡§ö‡•Å‡§®‡•á‡§Ç:"},
    "category_wrong": {"ru":"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ –æ–¥–Ω—É –∏–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –∫–Ω–æ–ø–∫–∞–º–∏ –Ω–∏–∂–µ:","en":"Please choose one of the categories using the buttons below:","es":"Por favor elige una de las categor√≠as con los botones de abajo:","ar":"ÿ±ÿ¨ÿßÿ°Ÿã ÿßÿÆÿ™ÿ± ŸÅÿ¶ÿ© ŸÖŸÜ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ± ÿ£ÿØŸÜÿßŸá:","hi":"‡§ï‡•É‡§™‡§Ø‡§æ ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§¨‡§ü‡§®‡•ã‡§Ç ‡§∏‡•á ‡§ï‡•ã‡§à ‡§∂‡•ç‡§∞‡•á‡§£‡•Ä ‡§ö‡•Å‡§®‡•á‡§Ç:"},
    "short_desc": {"ru":"–ö–æ—Ä–æ—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ? (–º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å)","en":"Short description? (optional)","es":"¬øDescripci√≥n corta? (opcional)","ar":"ŸàÿµŸÅ ŸÇÿµŸäÿ±ÿü (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä)","hi":"‡§õ‡•ã‡§ü‡§æ ‡§µ‡§ø‡§µ‡§∞‡§£? (‡§µ‡•à‡§ï‡§≤‡•ç‡§™‡§ø‡§ï)"},
    "send_photos": {"ru":"–û—Ç–ø—Ä–∞–≤–ª—è–π –æ–¥–Ω–æ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–æ—Ç–æ –ø–æ–¥—Ä—è–¥. –ö–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—à—å ‚Äî –Ω–∞–∂–º–∏ ¬´–ì–æ—Ç–æ–≤–æ¬ª (–∏–ª–∏ ¬´–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å¬ª).","en":"Send one or more photos. When done, press ‚ÄúDone‚Äù (or ‚ÄúSkip‚Äù).","es":"Env√≠a una o varias fotos. Cuando termines, pulsa ‚ÄúListo‚Äù (o ‚ÄúOmitir‚Äù).","ar":"ÿ£ÿ±ÿ≥ŸÑ ÿµŸàÿ±ÿ© ÿ£Ÿà ÿ£ŸÉÿ´ÿ±. ÿπŸÜÿØ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ÿßÿ∂ÿ∫ÿ∑ \"ÿ™ŸÖ\" (ÿ£Ÿà \"ÿ™ÿÆÿ∑Ÿä\").","hi":"‡§è‡§ï ‡§Ø‡§æ ‡§Ö‡§ß‡§ø‡§ï ‡§´‡•ã‡§ü‡•ã ‡§≠‡•á‡§ú‡•á‡§Ç‡•§ ‡§™‡•Ç‡§∞‡§æ ‡§π‡•ã‡§®‡•á ‡§™‡§∞ ‚Äú‡§π‡•ã ‡§ó‡§Ø‡§æ‚Äù (‡§Ø‡§æ ‚Äú‡§∏‡•ç‡§ï‡§ø‡§™‚Äù) ‡§¶‡§¨‡§æ‡§è‡§Å."},
    "photo_saved": {"ru":"üì∏ –§–æ—Ç–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ ({n}). –ú–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –µ—â—ë –∏–ª–∏ –Ω–∞–∂–∞—Ç—å ¬´–ì–æ—Ç–æ–≤–æ¬ª.","en":"üì∏ Photo saved ({n}). You can send more or press ‚ÄúDone‚Äù.","es":"üì∏ Foto guardada ({n}). Puedes enviar m√°s o pulsar ‚ÄúListo‚Äù.","ar":"üì∏ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿµŸàÿ±ÿ© ({n}). ŸäŸÖŸÉŸÜŸÉ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖÿ≤ŸäÿØ ÿ£Ÿà ÿßŸÑÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ \"ÿ™ŸÖ\".","hi":"üì∏ ‡§´‡•ã‡§ü‡•ã ‡§∏‡•á‡§µ ‡§π‡•Å‡§à ({n}). ‡§î‡§∞ ‡§≠‡•á‡§ú‡•á‡§Ç ‡§Ø‡§æ ‚Äú‡§π‡•ã ‡§ó‡§Ø‡§æ‚Äù ‡§¶‡§¨‡§æ‡§è‡§Å."},
    "point_added": {"ru":"‚úÖ –¢–æ—á–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞{photo}: <b>{category}</b>\n","en":"‚úÖ Point added{photo}: <b>{category}</b>\n","es":"‚úÖ Punto agregado{photo}: <b>{category}</b>\n","ar":"‚úÖ ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ŸÜŸÇÿ∑ÿ©{photo}: <b>{category}</b>\n","hi":"‚úÖ ‡§™‡•â‡§á‡§Ç‡§ü ‡§ú‡•ã‡§°‡§º‡§æ ‡§ó‡§Ø‡§æ{photo}: <b>{category}</b>\n"},
    "added_at": {"ru":"‚è± –¥–æ–±–∞–≤–ª–µ–Ω–æ: <b>{ts}</b>\n","en":"‚è± added: <b>{ts}</b>\n","es":"‚è± agregado: <b>{ts}</b>\n","ar":"‚è± ÿ™ŸÖÿ™ ÿßŸÑÿ•ÿ∂ÿßŸÅÿ©: <b>{ts}</b>\n","hi":"‚è± ‡§ú‡•ã‡§°‡§º‡§æ ‡§ó‡§Ø‡§æ: <b>{ts}</b>\n"},
    "limit_reached": {"ru":"–í—ã –¥–æ—Å—Ç–∏–≥–ª–∏ –ª–∏–º–∏—Ç–∞: –Ω–µ –±–æ–ª–µ–µ 2 —Ç–æ—á–µ–∫ –∑–∞ 12 —á–∞—Å–æ–≤.","en":"Limit reached: at most 2 points per 12 hours.","es":"L√≠mite alcanzado: m√°ximo 2 puntos cada 12 horas.","ar":"ÿ™ŸÖ ÿ®ŸÑŸàÿ∫ ÿßŸÑÿ≠ÿØ: ÿ®ÿ≠ÿØ ÿ£ŸÇÿµŸâ ŸÜŸÇÿ∑ÿ™ÿßŸÜ ŸÉŸÑ 12 ÿ≥ÿßÿπÿ©.","hi":"‡§∏‡•Ä‡§Æ‡§æ ‡§™‡•Ç‡§∞‡•Ä: 12 ‡§ò‡§Ç‡§ü‡•á ‡§Æ‡•á‡§Ç ‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ 2 ‡§™‡•â‡§á‡§Ç‡§ü‡•§"},
    "subscribe_set": {"ru":"üîî –ü–æ–¥–ø–∏—Å–∫–∞ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∞: {miles} mi –æ—Ç —Ç–µ–∫—É—â–µ–π –ª–æ–∫–∞—Ü–∏–∏ –Ω–∞ 12 —á–∞—Å–æ–≤. –ü—Ä–æ–¥–ª–∏—Ç—Å—è –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –Ω–æ–≤–æ–π –ª–æ–∫–∞—Ü–∏–∏.","en":"üîî Subscription set: {miles} mi around your current location for 12 hours. It prolongs when you send a new location.","es":"üîî Suscripci√≥n creada: {miles} mi alrededor de tu ubicaci√≥n por 12 horas. Se renueva al enviar nueva ubicaci√≥n.","ar":"üîî ÿ™ŸÖ ÿ•ÿπÿØÿßÿØ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ: ÿ∂ŸÖŸÜ {miles} ŸÖŸäŸÑ ÿ≠ŸàŸÑ ŸÖŸàŸÇÿπŸÉ ÿßŸÑÿ≠ÿßŸÑŸä ŸÑŸÖÿØÿ© 12 ÿ≥ÿßÿπÿ©. Ÿäÿ™ŸÖ ÿßŸÑÿ™ŸÖÿØŸäÿØ ÿπŸÜÿØ ÿ•ÿ±ÿ≥ÿßŸÑ ŸÖŸàŸÇÿπ ÿ¨ÿØŸäÿØ.","hi":"üîî ‡§∏‡§¶‡§∏‡•ç‡§Ø‡§§‡§æ ‡§∏‡•á‡§ü: ‡§Ü‡§™‡§ï‡•Ä ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§ï‡•á {miles} ‡§Æ‡•Ä‡§≤ ‡§§‡§ï 12 ‡§ò‡§Ç‡§ü‡•á ‡§ï‡•á ‡§≤‡§ø‡§è‡•§ ‡§®‡§à ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§≠‡•á‡§ú‡§®‡•á ‡§™‡§∞ ‡§¨‡§¢‡§º‡•á‡§ó‡•Ä‡•§"},
    "need_active_sub": {"ru":"–ß—Ç–æ–±—ã –¥–µ–ª–∏—Ç—å—Å—è Live-–ª–æ–∫–∞—Ü–∏–µ–π, —Å–Ω–∞—á–∞–ª–∞ –≤–∫–ª—é—á–∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ (–∫–Ω–æ–ø–∫–∞ ¬´üì° –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ¬ª).","en":"To share a live location, turn Tracking ON first (tap ‚Äúüì° Tracking‚Äù).","es":"Para compartir ubicaci√≥n en vivo, activa el rastreo primero (toca ‚Äúüì° Rastreo‚Äù).","ar":"ŸÑŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±ÿå ÿ¥ÿ∫ŸëŸÑ ÿßŸÑÿ™ÿ™ÿ®ÿπ ÿ£ŸàŸÑŸãÿß (ÿßÿ∂ÿ∫ÿ∑ ‚Äúüì° ÿßŸÑÿ™ÿ™ÿ®ÿπ‚Äù).","hi":"Live location ‡§ï‡•á ‡§≤‡§ø‡§è ‡§™‡§π‡§≤‡•á Tracking ‡§ö‡§æ‡§≤‡•Ç ‡§ï‡§∞‡•á‡§Ç (‚Äúüì° ‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó‚Äù)."},
    "live_howto": {
        "ru":"üü¢ –ö–∞–∫ –≤–∫–ª—é—á–∏—Ç—å Live-–ª–æ–∫–∞—Ü–∏—é:\n\n1) –ù–∞–∂–º–∏ —Å–∫—Ä–µ–ø–∫—É (üìé) ‚Üí –ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ.\n2) –í—ã–±–µ—Ä–∏ ‚Äò–ü–µ—Ä–µ–¥–∞–≤–∞—Ç—å –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏‚Äô.\n3) –ü–æ—Å—Ç–∞–≤—å —Å—Ä–æ–∫: 1 —á–∞—Å –∏–ª–∏ 8 —á–∞—Å–æ–≤.\n\n–ü–æ–∫–∞ Live –≤–∫–ª—é—á–µ–Ω–∞, –º—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Ü–µ–Ω—Ç—Ä –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è.",
        "en":"üü¢ How to enable Live Location:\n\n1) Tap paperclip (üìé) ‚Üí Location.\n2) Choose ‚ÄòShare live location‚Äô.\n3) Set duration: 1 hour or 8 hours.\n\nWhile live is on, we auto-refresh the tracking center.",
        "es":"üü¢ C√≥mo activar Ubicaci√≥n en vivo:\n\n1) Toca el clip (üìé) ‚Üí Ubicaci√≥n.\n2) Elige ‚ÄòCompartir ubicaci√≥n en vivo‚Äô.\n3) Pon duraci√≥n: 1 hora u 8 horas.\n\nMientras est√© activa, actualizamos el centro de rastreo autom√°ticamente.",
        "ar":"üü¢ ÿ∑ÿ±ŸäŸÇÿ© ÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±:\n\n1) ÿßÿ∂ÿ∫ÿ∑ ŸÖÿ¥ÿ®ŸÉ ÿßŸÑŸàÿ±ŸÇ (üìé) ‚Üí ÿßŸÑŸÖŸàŸÇÿπ.\n2) ÿßÿÆÿ™ÿ± ‚ÄòŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±‚Äô.\n3) ÿπŸäŸëŸÜ ÿßŸÑŸÖÿØÿ©: ÿ≥ÿßÿπÿ© ÿ£Ÿà 8 ÿ≥ÿßÿπÿßÿ™.\n\nÿ∑ÿßŸÑŸÖÿß ÿ£ŸÜ ÿßŸÑŸÄLive ŸÖŸÅÿπŸëŸÑ ÿ≥ŸÜÿ≠ÿØŸëÿ´ ŸÖÿ±ŸÉÿ≤ ÿßŸÑÿ™ÿ™ÿ®ÿπ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß.",
        "hi":"üü¢ ‡§≤‡§æ‡§á‡§µ ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§ï‡•à‡§∏‡•á ‡§ö‡§æ‡§≤‡•Ç ‡§ï‡§∞‡•á‡§Ç:\n\n1) ‡§™‡•á‡§™‡§∞‡§ï‡•ç‡§≤‡§ø‡§™ (üìé) ‚Üí ‡§≤‡•ã‡§ï‡•á‡§∂‡§®‡•§\n2) ‚Äò‡§≤‡§æ‡§á‡§µ ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§∂‡•á‡§Ø‡§∞ ‡§ï‡§∞‡•á‡§Ç‚Äô ‡§ö‡•Å‡§®‡•á‡§Ç‡•§\n3) ‡§Ö‡§µ‡§ß‡§ø ‡§∏‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç: 1 ‡§ò‡§Ç‡§ü‡§æ ‡§Ø‡§æ 8 ‡§ò‡§Ç‡§ü‡•á‡•§\n\n‡§ú‡§¨ ‡§§‡§ï ‡§≤‡§æ‡§á‡§µ ‡§ö‡§æ‡§≤‡•Ç ‡§π‡•à, ‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó ‡§∏‡•á‡§Ç‡§ü‡§∞ ‡§ë‡§ü‡•ã-‡§∞‡§ø‡§´‡•ç‡§∞‡•á‡§∂ ‡§π‡•ã‡§§‡§æ ‡§∞‡§π‡•á‡§ó‡§æ."
    },
    "live_soon_off": {"ru":"‚è∞ Live-–ª–æ–∫–∞—Ü–∏—è —Å–∫–æ—Ä–æ –æ—Ç–∫–ª—é—á–∏—Ç—Å—è (‚âà10 –º–∏–Ω). –ß—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∞–≤—Ç–æ-–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ, –≤–∫–ª—é—á–∏ Live —Å–Ω–æ–≤–∞:\nüìé –°–∫—Ä–µ–ø–∫–∞ ‚Üí –ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ ‚Üí –ü–µ—Ä–µ–¥–∞–≤–∞—Ç—å –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏.","en":"‚è∞ Live location will end in ‚âà10 min. To keep auto-refreshing, enable it again:\nüìé Paperclip ‚Üí Location ‚Üí Share live location.","es":"‚è∞ La ubicaci√≥n en vivo terminar√° en ‚âà10 min. Para seguir auto-actualizando, act√≠vala otra vez:\nüìé Clip ‚Üí Ubicaci√≥n ‚Üí Compartir ubicaci√≥n en vivo.","ar":"‚è∞ ÿ≥Ÿäÿ™ŸàŸÇŸÅ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ± ÿ®ÿπÿØ ‚âà10 ÿØŸÇÿßÿ¶ŸÇ. ŸÑŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ŸÅÿπŸëŸÑŸá ŸÖÿ¨ÿØÿØŸãÿß:\nüìé ŸÖÿ¥ÿ®ŸÉ ‚Üí ÿßŸÑŸÖŸàŸÇÿπ ‚Üí ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±.","hi":"‚è∞ ‡§≤‡§æ‡§á‡§µ ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ~10 ‡§Æ‡§ø‡§®‡§ü ‡§Æ‡•á‡§Ç ‡§¨‡§Ç‡§¶ ‡§π‡•ã‡§ó‡•Ä‡•§ ‡§ë‡§ü‡•ã-‡§∞‡§ø‡§´‡•ç‡§∞‡•á‡§∂ ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§ñ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ö‡§æ‡§≤‡•Ç ‡§ï‡§∞‡•á‡§Ç:\nüìé ‡§™‡•á‡§™‡§∞‡§ï‡•ç‡§≤‡§ø‡§™ ‚Üí ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‚Üí ‡§≤‡§æ‡§á‡§µ ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§∂‡•á‡§Ø‡§∞."},
    "need_fresh_loc": {"ru":"–õ–æ–∫–∞—Ü–∏—è —É—Å—Ç–∞—Ä–µ–ª–∞ (–Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ ‚â§ {mins} –º–∏–Ω). –ü—Ä–∏—à–ª–∏—Ç–µ —Ç–µ–∫—É—â—É—é –ª–æ–∫–∞—Ü–∏—é –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ.","en":"Location is stale (needs update ‚â§ {mins} min). Send a fresh location below and confirm again.","es":"La ubicaci√≥n est√° desactualizada (necesita actualizaci√≥n ‚â§ {mins} min). Env√≠a una ubicaci√≥n nueva abajo y confirma de nuevo.","ar":"ÿßŸÑŸÖŸàŸÇÿπ ŸÇÿØŸäŸÖ (Ÿäÿ≠ÿ™ÿßÿ¨ ÿ™ÿ≠ÿØŸäÿ´ ÿÆŸÑÿßŸÑ ‚â§ {mins} ÿØŸÇŸäŸÇÿ©). ÿ£ÿ±ÿ≥ŸÑ ŸÖŸàŸÇÿπŸãÿß ÿ¨ÿØŸäÿØŸãÿß ÿ£ÿØŸÜÿßŸá ÿ´ŸÖ ÿ£ŸÉÿØ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.","hi":"‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§™‡•Å‡§∞‡§æ‡§®‡•Ä ‡§π‡•à (‚â§ {mins} ‡§Æ‡§ø‡§®‡§ü ‡§Æ‡•á‡§Ç ‡§Ö‡§™‡§°‡•á‡§ü ‡§ö‡§æ‡§π‡§ø‡§è)‡•§ ‡§®‡•Ä‡§ö‡•á ‡§®‡§à ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§≠‡•á‡§ú‡•á‡§Ç ‡§î‡§∞ ‡§´‡§ø‡§∞ ‡§ï‡§®‡•ç‡§´‡§∞‡•ç‡§Æ ‡§ï‡§∞‡•á‡§Ç‡•§"},
    "too_far_to_confirm": {"ru":"–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –Ω–∞—Ö–æ–¥—è—Å—å –¥–∞–ª–µ–∫–æ –æ—Ç –º–µ—Å—Ç–∞ (> 0.5 mi –æ—Ç —Ç–æ—á–∫–∏).","en":"You are too far to confirm (> 0.5 mi from the point).","es":"Est√°s demasiado lejos para confirmar (> 0.5 mi del punto).","ar":"ÿ£ŸÜÿ™ ÿ®ÿπŸäÿØ ÿ¨ÿØŸãÿß ŸÑŸÑÿ™ÿ£ŸÉŸäÿØ (> 0.5 ŸÖŸäŸÑ ÿπŸÜ ÿßŸÑŸÜŸÇÿ∑ÿ©).","hi":"‡§Ü‡§™ ‡§¨‡§π‡•Å‡§§ ‡§¶‡•Ç‡§∞ ‡§π‡•à‡§Ç, ‡§ï‡§®‡•ç‡§´‡§∞‡•ç‡§Æ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á (> 0.5 ‡§Æ‡•Ä‡§≤)‡•§"},
    "tracking_on": {"ru":"üì° –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ üü¢ –í–ö–õ–Æ–ß–ï–ù–û","en":"üì° Tracking üü¢ ON","es":"üì° Rastreo üü¢ ACTIVADO","ar":"üì° ÿßŸÑÿ™ÿ™ÿ®ÿπ üü¢ ŸÇŸäÿØ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ","hi":"üì° ‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó üü¢ ‡§ö‡§æ‡§≤‡•Ç"},
    "tracking_off": {"ru":"üì° –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ üî¥ –í–´–ö–õ–Æ–ß–ï–ù–û","en":"üì° Tracking üî¥ OFF","es":"üì° Rastreo üî¥ DESACTIVADO","ar":"üì° ÿßŸÑÿ™ÿ™ÿ®ÿπ üî¥ ŸÖÿ™ŸàŸÇŸÅ","hi":"üì° ‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó üî¥ ‡§¨‡§Ç‡§¶"},
    "pick_tracking_radius": {"ru":"–í—ã–±–µ—Ä–∏ —Ä–∞–¥–∏—É—Å –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è:","en":"Choose tracking radius:","es":"Elige el radio de rastreo:","ar":"ÿßÿÆÿ™ÿ± ŸÜÿµŸÅ ŸÇÿ∑ÿ± ÿßŸÑÿ™ÿ™ÿ®ÿπ:","hi":"‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó ‡§∞‡•á‡§°‡§ø‡§Ø‡§∏ ‡§ö‡•Å‡§®‡•á‡§Ç:"},

    # –Ω–æ–≤—ã–µ –∫–ª—é—á–∏
    "send_new_point_loc": {"ru":"–û–∫! –ü—Ä–∏—à–ª–∏ –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é –Ω–æ–≤–æ–π —Ç–æ—á–∫–∏.","en":"OK! Send the location of the new point.","es":"¬°OK! Env√≠a la ubicaci√≥n del nuevo punto.","ar":"ÿ≠ÿ≥ŸÜŸãÿß! ÿ£ÿ±ÿ≥ŸÑ ŸÖŸàŸÇÿπ ÿßŸÑŸÜŸÇÿ∑ÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©.","hi":"‡§†‡•Ä‡§ï ‡§π‡•à! ‡§®‡§à ‡§™‡•â‡§á‡§Ç‡§ü ‡§ï‡•Ä ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§≠‡•á‡§ú‡•ã."},
    "press_to_confirm": {"ru":"–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —Ç–æ—á–∫—É:","en":"Tap to confirm the point:","es":"Pulsa para confirmar el punto:","ar":"ÿßÿ∂ÿ∫ÿ∑ ŸÑÿ™ÿ£ŸÉŸäÿØ ÿßŸÑŸÜŸÇÿ∑ÿ©:","hi":"‡§™‡•â‡§á‡§Ç‡§ü ‡§ï‡§®‡•ç‡§´‡§∞‡•ç‡§Æ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ü‡•à‡§™ ‡§ï‡§∞‡•á‡§Ç:"},
    "open_in_map": {"ru":"–û—Ç–∫—Ä—ã—Ç—å –≤ –∫–∞—Ä—Ç–µ","en":"Open in map","es":"Abrir en el mapa","ar":"ÿßŸÅÿ™ÿ≠ ŸÅŸä ÿßŸÑÿÆÿ±Ÿäÿ∑ÿ©","hi":"‡§Æ‡§æ‡§®‡§ö‡§ø‡§§‡•ç‡§∞ ‡§Æ‡•á‡§Ç ‡§ñ‡•ã‡§≤‡•á‡§Ç"},
    "last_confirmation": {"ru":"–ø–æ—Å–ª–µ–¥–Ω–µ–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ","en":"last confirmation","es":"√∫ltima confirmaci√≥n","ar":"ÿ¢ÿÆÿ± ÿ™ÿ£ŸÉŸäÿØ","hi":"‡§Ö‡§Ç‡§§‡§ø‡§Æ ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø"},
    "added_label": {"ru":"–¥–æ–±–∞–≤–ª–µ–Ω–æ","en":"added","es":"agregado","ar":"ÿ£ÿ∂ŸäŸÅ","hi":"‡§ú‡•ã‡§°‡§º‡§æ ‡§ó‡§Ø‡§æ"},
    "btn_done": {"ru":"–ì–æ—Ç–æ–≤–æ","en":"Done","es":"Listo","ar":"ÿ™ŸÖ","hi":"‡§π‡•ã ‡§ó‡§Ø‡§æ"},
    "btn_skip": {"ru":"–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å","en":"Skip","es":"Omitir","ar":"ÿ™ÿÆÿ∑Ÿä","hi":"‡§∏‡•ç‡§ï‡§ø‡§™"},
    "confirmations_label": {"ru":"–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–π","en":"Confirmations","es":"Confirmaciones","ar":"ÿπÿØÿØ ÿßŸÑÿ™ÿ£ŸÉŸäÿØÿßÿ™","hi":"‡§™‡•Å‡§∑‡•ç‡§ü‡§ø‡§Ø‡§æ‡§Å"},
    "checking": {"ru":"‚è≥ –ü—Ä–æ–≤–µ—Ä—è—é...","en":"‚è≥ Checking...","es":"‚è≥ Comprobando...","ar":"‚è≥ ÿ¨ÿßÿ±Ÿç ÿßŸÑŸÅÿ≠ÿµ...","hi":"‚è≥ ‡§ú‡§æ‡§Å‡§ö ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å..."},
    "wrong_button": {"ru":"–ù–µ–≤–µ—Ä–Ω–∞—è –∫–Ω–æ–ø–∫–∞.","en":"Wrong button.","es":"Bot√≥n incorrecto.","ar":"ÿ≤ÿ± ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠.","hi":"‡§ó‡§≤‡§§ ‡§¨‡§ü‡§®."},
    "point_not_found": {"ru":"–¢–æ—á–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.","en":"Point not found.","es":"Punto no encontrado.","ar":"ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÜŸÇÿ∑ÿ©.","hi":"‡§™‡•â‡§á‡§Ç‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡•§"},
    "point_outdated": {"ru":"–≠—Ç–∞ —Ç–æ—á–∫–∞ —É—Å—Ç–∞—Ä–µ–ª–∞ (—Å—Ç–∞—Ä—à–µ 12 —á–∞—Å–æ–≤).","en":"This point is outdated (older than 12 hours).","es":"Este punto est√° desactualizado (m√°s de 12 horas).","ar":"Ÿáÿ∞Ÿá ÿßŸÑŸÜŸÇÿ∑ÿ© ŸÇÿØŸäŸÖÿ© (ÿ£ŸÇÿØŸÖ ŸÖŸÜ 12 ÿ≥ÿßÿπÿ©).","hi":"‡§Ø‡§π ‡§™‡•â‡§á‡§Ç‡§ü ‡§™‡•Å‡§∞‡§æ‡§®‡§æ ‡§π‡•à (12 ‡§ò‡§Ç‡§ü‡•á ‡§∏‡•á ‡§Ö‡§ß‡§ø‡§ï)‡•§"},
    "cant_confirm_own": {"ru":"–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞—Ç—å —Å–≤–æ—é —Ç–æ—á–∫—É. –ü—É—Å—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–¥—è—Ç –¥—Ä—É–≥–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏.","en":"You can‚Äôt confirm your own point. Ask other users to confirm.","es":"No puedes confirmar tu propio punto. Pide a otros usuarios que confirmen.","ar":"ŸÑÿß ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ£ŸÉŸäÿØ ŸÜŸÇÿ∑ÿ™ŸÉ ÿßŸÑÿÆÿßÿµÿ©. ÿØÿπ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑÿ¢ÿÆÿ±ŸäŸÜ Ÿäÿ§ŸÉÿØŸàŸÜ.","hi":"‡§Ü‡§™ ‡§Ö‡§™‡§®‡•Ä ‡§π‡•Ä ‡§™‡•â‡§á‡§Ç‡§ü ‡§ï‡•Ä ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á‡•§ ‡§Ö‡§®‡•ç‡§Ø ‡§Ø‡•Ç‡§ú‡§º‡§∞‡•ç‡§∏ ‡§∏‡•á ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§ï‡§∞‡§µ‡§æ‡§è‡§Å."},
    "confirmed_title": {"ru":"‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ","en":"‚úÖ Confirmed","es":"‚úÖ Confirmado","ar":"‚úÖ ÿ™ŸÖ ÿßŸÑÿ™ÿ£ŸÉŸäÿØ","hi":"‚úÖ ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§π‡•Å‡§à"},
    "total_confirmations": {"ru":"–í—Å–µ–≥–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–π","en":"Total confirmations","es":"Confirmaciones totales","ar":"ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ™ÿ£ŸÉŸäÿØÿßÿ™","hi":"‡§ï‡•Å‡§≤ ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø‡§Ø‡§æ‡§Å"},
}

# UI helpers

def start_kb(lang: str, tracking_active: bool):
    send_loc = ("üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –ª–æ–∫–∞—Ü–∏—é" if lang=="ru" else
                ("üìç Send location" if lang=="en" else
                 ("üìç Enviar ubicaci√≥n" if lang=="es" else
                  ("üìç ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑŸÖŸàŸÇÿπ" if lang=="ar" else "üìç ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§≠‡•á‡§ú‡•á‡§Ç"))))
    add_spot = ("‚ûï –î–æ–±–∞–≤–∏—Ç—å —Ç–æ—á–∫—É" if lang=="ru" else
                ("‚ûï Add spot" if lang=="en" else
                 ("‚ûï Agregar punto" if lang=="es" else
                  ("‚ûï ÿ•ÿ∂ÿßŸÅÿ© ŸÜŸÇÿ∑ÿ©" if lang=="ar" else "‚ûï ‡§™‡•â‡§á‡§Ç‡§ü ‡§ú‡•ã‡§°‡§º‡•á‡§Ç"))))
    tracking_base = ("üì° –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ" if lang=="ru" else
                     ("üì° Tracking" if lang=="en" else
                      ("üì° Rastreo" if lang=="es" else
                       ("üì° ÿßŸÑÿ™ÿ™ÿ®ÿπ" if lang=="ar" else "üì° ‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó"))))
    tracking = f"{tracking_base} {'üü¢' if tracking_active else 'üî¥'}"
    lang_label = ("–Ø–∑—ã–∫" if lang=="ru" else
                  ("Language" if lang=="en" else
                   ("Idioma" if lang=="es" else
                    ("ÿßŸÑŸÑÿ∫ÿ©" if lang=="ar" else "‡§≠‡§æ‡§∑‡§æ"))))
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text=send_loc, request_location=True)],
            [KeyboardButton(text=add_spot), KeyboardButton(text=tracking)],
            [KeyboardButton(text=lang_label)],
        ],
        resize_keyboard=True
    )

def home_kb():
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="/start")]],
        resize_keyboard=True,
        one_time_keyboard=True
    )

def location_request_kb(lang: str):
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text=("üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –ª–æ–∫–∞—Ü–∏—é" if lang=="ru" else
                                        ("üìç Send location" if lang=="en" else
                                         ("üìç Enviar ubicaci√≥n" if lang=="es" else
                                          ("üìç ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑŸÖŸàŸÇÿπ" if lang=="ar" else "üìç ‡§≤‡•ã‡§ï‡•á‡§∂‡§® ‡§≠‡•á‡§ú‡•á‡§Ç"))
                                        )), request_location=True)]],
        resize_keyboard=True,
        one_time_keyboard=True
    )

def radius_kb():
    return InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(text="10 mi", callback_data="r:10"),
        InlineKeyboardButton(text="50 mi", callback_data="r:50"),
        InlineKeyboardButton(text="100 mi", callback_data="r:100"),
    ]])

def track_radius_kb():
    return InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(text="10 mi", callback_data="track:10"),
        InlineKeyboardButton(text="50 mi", callback_data="track:50"),
        InlineKeyboardButton(text="100 mi", callback_data="track:100"),
    ]])

def sub_radius_kb():
    return InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(text="10 mi", callback_data="sub:10"),
        InlineKeyboardButton(text="50 mi", callback_data="sub:50"),
        InlineKeyboardButton(text="100 mi", callback_data="sub:100"),
    ]])

def confirm_kb(poi_id: int, lang: str) -> InlineKeyboardMarkup:
    label = STRINGS["confirm_button"].get(lang, STRINGS["confirm_button"]["en"])
    return InlineKeyboardMarkup(
        inline_keyboard=[[InlineKeyboardButton(text=label, callback_data=f"cf:{poi_id}")]]
    )

# --- –ö–∞—Ç–µ–≥–æ—Ä–∏–∏ ---
CATEGORY_IDS = ("road_closure", "public_warning")
CATEGORY_LABELS = {
    "ru": {"road_closure": "üö® –†–µ–π–¥ ICE", "public_warning": "üõÉ –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–π –ø—É–Ω–∫—Ç ICE"},
    "en": {"road_closure": "üö® ICE raid", "public_warning": "üõÉ ICE checkpoint"},
    "es": {"road_closure": "üö® Redada de ICE", "public_warning": "üõÉ puesto de control de ICE"},
    "ar": {"road_closure": "üö® ICE raid", "public_warning": "üõÉ ICE checkpoint"},
    "hi": {"road_closure": "üö® ICE raid", "public_warning": "üõÉ ICE checkpoint"},
}

def category_kb(lang: str) -> ReplyKeyboardMarkup:
    labels = CATEGORY_LABELS.get(lang, CATEGORY_LABELS["en"])
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text=labels["road_closure"]), KeyboardButton(text=labels["public_warning"])]],
        resize_keyboard=True,
        one_time_keyboard=True
    )

def category_id_from_text(txt: str) -> Optional[str]:
    s = (txt or "").strip()
    for lang_map in CATEGORY_LABELS.values():
        for cid, label in lang_map.items():
            if s == label:
                return cid
    return None

# ===== /lang =====
def lang_kb() -> InlineKeyboardMarkup:
    rows = [
        [InlineKeyboardButton(text=f"üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data="lang:ru"),
         InlineKeyboardButton(text=f"üá∫üá∏ English", callback_data="lang:en")],
        [InlineKeyboardButton(text=f"üá™üá∏ Espa√±ol (LatAm)", callback_data="lang:es"),
         InlineKeyboardButton(text=f"üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©", callback_data="lang:ar")],
        [InlineKeyboardButton(text=f"üáÆüá≥ ‡§π‡§ø‡§®‡•ç‡§¶‡•Ä", callback_data="lang:hi")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=rows)

@router.message(F.text.lower().in_({"/lang", "language", "—è–∑—ã–∫", "idioma", "ÿßŸÑŸÑÿ∫ÿ©", "‡§≠‡§æ‡§∑‡§æ"}))
async def on_lang(m: Message):
    await m.answer("Select language / –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:", reply_markup=lang_kb())

@router.callback_query(F.data.startswith("lang:"))
async def on_lang_pick(cq: CallbackQuery):
    lang = cq.data.split(":", 1)[1]
    await set_user_lang(cq.from_user.id, lang)
    tracking_active = await has_active_subscription(cq.from_user.id)
    badge = await get_subscription_badge(cq.from_user.id)
    await cq.message.answer(
        L(lang, "start_intro") + badge,
        reply_markup=start_kb(lang, tracking_active)
    )
    await cq.answer()

# ===== simple helpers =====
def L(lang: str, key: str, **kwargs) -> str:
    text = STRINGS.get(key, {}).get(lang) or STRINGS.get(key, {}).get(DEFAULT_LANG) or key
    if kwargs:
        try:
            return text.format(**kwargs)
        except Exception:
            return text
    return text

def t_done(lang: str) -> str: return STRINGS["btn_done"].get(lang, STRINGS["btn_done"]["en"])
def t_skip(lang: str) -> str: return STRINGS["btn_skip"].get(lang, STRINGS["btn_skip"]["en"])

def done_or_skip_kb(lang: str):
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text=t_done(lang))],[KeyboardButton(text=t_skip(lang))]],
        resize_keyboard=True,
        one_time_keyboard=True
    )

def is_done(text: str) -> bool:
    txt = (text or "").strip().lower()
    return txt in {STRINGS["btn_done"][k].lower() for k in STRINGS["btn_done"]}

def is_skip(text: str) -> bool:
    txt = (text or "").strip().lower()
    return txt in {STRINGS["btn_skip"][k].lower() for k in STRINGS["btn_skip"]}

async def get_user_lang(tg_user_id: int) -> str:
    assert pool is not None
    async with pool.acquire() as con:
        lang = await con.fetchval("SELECT lang FROM app_user WHERE tg_user_id=$1", tg_user_id)
    return lang if lang in LANGS else DEFAULT_LANG

async def set_user_lang(tg_user_id: int, lang: str):
    if lang not in LANGS:
        lang = DEFAULT_LANG
    assert pool is not None
    async with pool.acquire() as con:
        await con.execute(
            """
            INSERT INTO app_user(tg_user_id, lang)
            VALUES ($1, $2)
            ON CONFLICT (tg_user_id) DO UPDATE SET lang=EXCLUDED.lang
            """,
            tg_user_id, lang
        )

def fmt_ts(ts: Optional[datetime]) -> str:
    if ts is None:
        return "-"
    try:
        return ts.astimezone().strftime("%Y-%m-%d %H:%M")
    except Exception:
        return ts.strftime("%Y-%m-%d %H:%M")

async def ensure_user(tg_user_id: int, username: Optional[str]) -> int:
    assert pool is not None
    async with pool.acquire() as con:
        await con.execute(
            """
            insert into app_user(tg_user_id, username)
            values ($1, $2)
            on conflict (tg_user_id) do update set username = excluded.username
            """,
            tg_user_id, username
        )
        row = await con.fetchrow("select id from app_user where tg_user_id=$1", tg_user_id)
        return int(row["id"])

# –ø–æ—Å–ª–µ–¥–Ω—è—è –ª–æ–∫–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è + –≤—Ä–µ–º—è –ø–æ–ª—É—á–µ–Ω–∏—è
last_loc: Dict[int, Tuple[float, float, datetime]] = {}
from asyncio import create_task, Task, sleep
live_reminders: Dict[Tuple[int,int], Task] = {}

def miles_to_meters(mi: float) -> float:
    return mi * 1609.344

def is_location_fresh(uid: int) -> bool:
    if uid not in last_loc:
        return False
    _, _, ts = last_loc[uid]
    age = datetime.now(timezone.utc) - ts
    return age <= timedelta(minutes=FRESH_LOCATION_MINUTES)

# ========= FSM =========
class AddPoi(StatesGroup):
    waiting_location = State()
    waiting_category = State()
    waiting_description = State()
    waiting_photo = State()

# ========= HANDLERS =========
async def get_subscription_badge(uid: int) -> str:
    assert pool is not None
    async with pool.acquire() as con:
        r = await con.fetchrow(
            """
            SELECT radius_m, is_active, last_refreshed_at
            FROM subscriptions
            WHERE tg_user_id=$1
            ORDER BY created_at DESC
            LIMIT 1
            """,
            uid,
        )
    if not r:
        return "üî¥"
    is_active = bool(r["is_active"])
    miles = (r["radius_m"] or 0.0) / 1609.344
    until = (r["last_refreshed_at"] or datetime.now(timezone.utc)) + timedelta(hours=SUBSCRIPTION_TTL_HOURS)
    badge = "üü¢" if is_active else "üî¥"
    return f"{badge} ‚Ä¢ {miles:.0f} mi ‚Ä¢ {fmt_ts(until)}"

async def has_active_subscription(tg_user_id: int) -> bool:
    assert pool is not None
    async with pool.acquire() as con:
        ok = await con.fetchval(
            """
            SELECT EXISTS (
              SELECT 1 FROM subscriptions
              WHERE tg_user_id=$1 AND is_active
                AND last_refreshed_at >= NOW() - INTERVAL '30 days'
            )
            """,
            tg_user_id,
        )
    return bool(ok)

async def schedule_live_reminder(user_id: int, message_id: int, expire_at: datetime):
    key = (user_id, message_id)
    if key in live_reminders:
        try:
            live_reminders[key].cancel()
        except Exception:
            pass
    remind_at = expire_at - timedelta(minutes=10)
    delay = (remind_at - datetime.now(timezone.utc)).total_seconds()
    if delay <= 0:
        delay = 1

    async def _job():
        try:
            lang = await get_user_lang(user_id)
            await sleep(delay)
            await bot.send_message(
                chat_id=user_id,
                text=L(lang, "live_soon_off")
            )
        except Exception:
            pass
        finally:
            live_reminders.pop(key, None)
    live_reminders[key] = create_task(_job())

@router.message(CommandStart())
async def on_start(m: Message):
    lang = await get_user_lang(m.from_user.id)
    badge = await get_subscription_badge(m.from_user.id)
    tracking_active = await has_active_subscription(m.from_user.id)
    await m.answer(
        L(lang, "start_intro") + badge,
        reply_markup=start_kb(lang, tracking_active)
    )

# –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ª–æ–∫–∞—Ü–∏—é (—Ñ–∏–∫—Å–∏—Ä—É–µ–º –¥—É–±–ª–∏–∫–∞—Ç –≤—ã–≤–æ–¥–∞)
@router.message(StateFilter(None), F.location)
async def on_location(m: Message):
    # live-–ª–æ–∫–∞—Ü–∏—è ‚Äî –æ—Ç–¥–µ–ª—å–Ω—ã–π —Ö—ç–Ω–¥–ª–µ—Ä
    if getattr(m.location, 'live_period', None):
        return await on_live_location_start(m)

    lat, lon = m.location.latitude, m.location.longitude
    last_loc[m.from_user.id] = (lat, lon, datetime.now(timezone.utc))

    # –µ—Å–ª–∏ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–æ–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ ‚Äî –æ–±–Ω–æ–≤–ª—è–µ–º —Ü–µ–Ω—Ç—Ä –∏ –ø—Ä–æ–¥–ª–µ–≤–∞–µ–º "—Å–≤–µ–∂–µ—Å—Ç—å"
    assert pool is not None
    async with pool.acquire() as con:
        await con.execute(
            """
            UPDATE subscriptions
            SET center = ST_MakePoint($2,$3)::geography,
                last_refreshed_at = NOW(),
                is_active = TRUE
            WHERE tg_user_id = $1
            """,
            m.from_user.id, float(lon), float(lat)
        )

    lang = await get_user_lang(m.from_user.id)
    await m.answer(
        L(lang, "location_saved", lat=lat, lon=lon),
        reply_markup=radius_kb()
    )

# –ü–æ–∏—Å–∫ –±–ª–∏–∂–∞–π—à–∏—Ö —Ç–æ—á–µ–∫ (—Ñ–∏–ª—å—Ç—Ä 12—á)
@router.callback_query(F.data.startswith("r:"))
async def on_radius(cq: CallbackQuery):
    uid = cq.from_user.id
    lang = await get_user_lang(uid)
    if uid not in last_loc:
        await cq.message.answer(L(lang, "send_location_first"),
                                reply_markup=start_kb(lang, await has_active_subscription(uid)))
        await cq.answer()
        return

    miles = int(cq.data.split(":")[1])
    lat, lon, _ = last_loc[uid]
    radius_m = miles_to_meters(miles)

    assert pool is not None
    async with pool.acquire() as con:
        rows = await con.fetch(
            """
            SELECT
                p.id, p.title, p.category, p.description,
                ST_Y(p.geom::geometry) AS lat,
                ST_X(p.geom::geometry) AS lon,
                ST_Distance(p.geom, ST_MakePoint($1,$2)::geography) AS dist_m,
                COUNT(pc.poi_id) AS confirmations,
                MAX(pc.created_at) AS last_conf,
                p.created_at AS created_at,
                ph.photos AS photos
            FROM poi p
            LEFT JOIN poi_confirmation pc ON pc.poi_id = p.id
            LEFT JOIN LATERAL (
              SELECT array_agg(file_id ORDER BY created_at) AS photos
              FROM poi_photo pp
              WHERE pp.poi_id = p.id
            ) ph ON TRUE
            WHERE ST_DWithin(p.geom, ST_MakePoint($1,$2)::geography, $3)
            GROUP BY p.id, p.title, p.category, p.description, p.geom, p.created_at, ph.photos
            HAVING COALESCE(MAX(pc.created_at), p.created_at) >= NOW() - INTERVAL '12 hours'
            ORDER BY p.geom <-> ST_MakePoint($1,$2)::geography
            LIMIT 50;
            """,
            float(lon), float(lat), float(radius_m)
        )

    if not rows:
        await cq.message.answer(L(lang, "no_points_in_radius", miles=miles))
        await bot.send_message(cq.message.chat.id, L(lang, "back_to_start"), reply_markup=home_kb())
        await cq.answer()
        return

    for r in rows[:15]:
        dist_mi = r["dist_m"] / 1609.344
        gmaps = f"https://www.google.com/maps/search/?api=1&query={r['lat']},{r['lon']}"
        has_conf = r["last_conf"] is not None
        ts = r["last_conf"] if has_conf else r["created_at"]
        when_label = L(lang, "last_confirmation") if has_conf else L(lang, "added_label")

        header = f"üìç <b>{r['category']}</b>\n" if not r["description"] else f"üìç <b>{r['category']}</b> ‚Äî {r['description']}\n"
        caption = (
            header
            + f"‚è± {when_label}: <b>{fmt_ts(ts)}</b>\n"
            + f"~{dist_mi:.1f} mi ‚Ä¢ {L(lang,'confirmations_label')}: <b>{r['confirmations']}</b>\n"
            + f"<a href='{gmaps}'>{L(lang,'open_in_map')}</a> ‚Ä¢ ({L(lang,'confirm_button')})"
        )

        photos: Optional[List[str]] = r["photos"]
        if photos:
            medias: List[InputMediaPhoto] = []
            for i, fid in enumerate(photos[:10]):
                if i == 0:
                    medias.append(InputMediaPhoto(media=fid, caption=caption, parse_mode=ParseMode.HTML))
                else:
                    medias.append(InputMediaPhoto(media=fid))
            await bot.send_media_group(chat_id=cq.message.chat.id, media=medias)
            await bot.send_message(
                chat_id=cq.message.chat.id,
                text=L(lang, "press_to_confirm"),
                reply_markup=confirm_kb(r["id"], lang)
            )
        else:
            await cq.message.answer(caption, disable_web_page_preview=True, reply_markup=confirm_kb(r["id"], lang))

    await bot.send_message(cq.message.chat.id, L(lang, "back_to_start"), reply_markup=home_kb())
    await cq.answer()

# ===== –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è Live-–ª–æ–∫–∞—Ü–∏–∏ =====
@router.message(F.text.lower().contains("live"))
async def live_help(m: Message):
    lang = await get_user_lang(m.from_user.id)
    if not await has_active_subscription(m.from_user.id):
        await m.answer(L(lang, "need_active_sub"),
                       reply_markup=start_kb(lang, await has_active_subscription(m.from_user.id)))
        return
    await m.answer(L(lang, "live_howto"),
                   reply_markup=start_kb(lang, await has_active_subscription(m.from_user.id)))

# ===== –û–±—Ä–∞–±–æ—Ç–∫–∞ Live-–ª–æ–∫–∞—Ü–∏–∏ =====
@router.message(StateFilter(None), F.location & (F.location.live_period != None))
async def on_live_location_start(m: Message):
    lang = await get_user_lang(m.from_user.id)
    if not await has_active_subscription(m.from_user.id):
        await m.answer(L(lang, "need_active_sub"))
        return

    lat, lon = m.location.latitude, m.location.longitude
    last_loc[m.from_user.id] = (lat, lon, datetime.now(timezone.utc))

    assert pool is not None
    async with pool.acquire() as con:
        await con.execute(
            """
            UPDATE subscriptions
               SET center = ST_MakePoint($2,$3)::geography,
                   last_refreshed_at = NOW(),
                   is_active = TRUE
             WHERE tg_user_id = $1
            """,
            m.from_user.id, float(lon), float(lat)
        )

    live_period = int(m.location.live_period or 0)
    expire_at = (m.date or datetime.now(timezone.utc)).astimezone(timezone.utc) + timedelta(seconds=live_period)
    await schedule_live_reminder(m.from_user.id, m.message_id, expire_at)

    await m.answer("‚úÖ Live-location is ON. We'll auto-extend your subscription while it's active.")

@router.edited_message(F.location)
async def on_live_location_update(m: Message):
    if not await has_active_subscription(m.from_user.id):
        return
    lat, lon = m.location.latitude, m.location.longitude
    last_loc[m.from_user.id] = (lat, lon, datetime.now(timezone.utc))

    assert pool is not None
    async with pool.acquire() as con:
        await con.execute(
            """
            UPDATE subscriptions
               SET center = ST_MakePoint($2,$3)::geography,
                   last_refreshed_at = NOW(),
                   is_active = TRUE
             WHERE tg_user_id = $1
            """,
            m.from_user.id, float(lon), float(lat)
        )

# ===== –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–µ–∫ (–ø–æ—à–∞–≥–æ–≤–æ —Å –º—É–ª—å—Ç–∏—Ñ–æ—Ç–æ) =====
@router.message(F.text.lower() == "‚ûï –¥–æ–±–∞–≤–∏—Ç—å —Ç–æ—á–∫—É")
@router.message(F.text.lower() == "‚ûï add spot")
@router.message(F.text.lower() == "‚ûï agregar punto")
@router.message(F.text.contains("ÿ•ÿ∂ÿßŸÅÿ©"))
@router.message(F.text.contains("‡§™‡•â‡§á‡§Ç‡§ü"))
async def add_start(m: Message, state: FSMContext):
    lang = await get_user_lang(m.from_user.id)
    await state.set_state(AddPoi.waiting_location)
    await m.answer(L(lang, "send_new_point_loc"), reply_markup=location_request_kb(lang))

@router.message(AddPoi.waiting_location, F.location)
async def add_loc(m: Message, state: FSMContext):
    await state.update_data(lat=m.location.latitude, lon=m.location.longitude)
    await state.set_state(AddPoi.waiting_category)
    lang = await get_user_lang(m.from_user.id)
    await m.answer(L(lang, "choose_category"), reply_markup=category_kb(lang))

@router.message(AddPoi.waiting_category, F.text)
async def add_category(m: Message, state: FSMContext):
    cid = category_id_from_text(m.text)
    if not cid:
        lang = await get_user_lang(m.from_user.id)
        await m.answer(L(lang, "category_wrong"), reply_markup=category_kb(lang))
        return
    await state.update_data(category_id=cid)
    await state.set_state(AddPoi.waiting_description)
    lang = await get_user_lang(m.from_user.id)
    await m.answer(L(lang, "short_desc"), reply_markup=ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text=STRINGS["btn_skip"][lang])]],
        resize_keyboard=True,
        one_time_keyboard=True
    ))

@router.message(AddPoi.waiting_description, F.text)
async def add_desc(m: Message, state: FSMContext):
    txt = (m.text or "").strip()
    lang = await get_user_lang(m.from_user.id)
    desc = None if (txt == "" or txt == "-" or is_skip(txt)) else txt
    await state.update_data(description=desc, photos=[])
    await state.set_state(AddPoi.waiting_photo)
    await m.answer(L(lang, "send_photos"), reply_markup=done_or_skip_kb(lang))

@router.message(AddPoi.waiting_photo, F.photo)
async def add_collect_photo(m: Message, state: FSMContext):
    file_id = m.photo[-1].file_id
    data = await state.get_data()
    photos: List[str] = data.get("photos", [])
    photos.append(file_id)
    await state.update_data(photos=photos)
    lang = await get_user_lang(m.from_user.id)
    await m.answer(L(lang, "photo_saved", n=len(photos)), reply_markup=done_or_skip_kb(lang))

@router.message(AddPoi.waiting_photo, F.text)
async def add_finish_or_skip(m: Message, state: FSMContext):
    lang = await get_user_lang(m.from_user.id)
    if is_done(m.text):
        data = await state.get_data()
        photos: List[str] = data.get("photos", [])
        await finalize_poi_creation(m, state, photos)
        return
    if is_skip(m.text):
        await finalize_poi_creation(m, state, [])
        return

async def finalize_poi_creation(m: Message, state: FSMContext, file_ids: List[str]):
    data = await state.get_data()
    lat, lon = float(data["lat"]), float(data["lon"])
    cid = data["category_id"]
    lang = await get_user_lang(m.from_user.id)
    category_label = CATEGORY_LABELS.get(lang, CATEGORY_LABELS["en"])[cid]
    title = category_label
    desc = data.get("description")
    user_row_id = await ensure_user(m.from_user.id, m.from_user.username)

    # ---- –õ–ò–ú–ò–¢: –Ω–µ –±–æ–ª–µ–µ 2 —Ç–æ—á–µ–∫ –∑–∞ 12 —á–∞—Å–æ–≤ ----
    assert pool is not None
    async with pool.acquire() as con:
        recent_cnt = await con.fetchval(
            """
            SELECT COUNT(*)
            FROM poi
            WHERE created_by = $1 AND created_at >= NOW() - INTERVAL '12 hours'
            """,
            user_row_id,
        )
        if int(recent_cnt or 0) >= ADD_LIMIT_COUNT:
            await m.answer(L(lang, "limit_reached"),
                           reply_markup=start_kb(lang, await has_active_subscription(m.from_user.id)))
            return

        row = await con.fetchrow(
            """
            INSERT INTO poi(title, category, geom, description, created_by)
            VALUES ($1,$2, ST_MakePoint($3,$4)::geography, $5, $6)
            RETURNING id, created_at
            """,
            title, category_label, float(lon), float(lat), desc, user_row_id
        )
        poi_id = int(row["id"])
        for fid in file_ids[:20]:
            await con.execute(
                "INSERT INTO poi_photo(poi_id, file_id, user_id) VALUES ($1,$2,$3)",
                poi_id, fid, user_row_id
            )

    await state.clear()
    gmaps = f"https://www.google.com/maps/search/?api=1&query={lat},{lon}"
    photo_note = f" —Å —Ñ–æ—Ç–æ ({len(file_ids)})" if file_ids else ""

    header = L(lang, "point_added", photo=photo_note, category=category_label)
    if desc:
        header += f"{desc}\n"

    await m.answer(
        header +
        L(lang, "added_at", ts=fmt_ts(row['created_at'])) +
        f"<a href='{gmaps}'>{L(lang,'open_in_map')}</a>",
        disable_web_page_preview=True,
        reply_markup=start_kb(lang, await has_active_subscription(m.from_user.id))
    )

    await notify_subscribers(
        poi_id=poi_id,
        lat=lat, lon=lon,
        category=category_label,
        description=desc,
        created_at=row['created_at'],
        photos=file_ids[:10],
        exclude_tg_id=m.from_user.id
    )

# ===== üì° –í–ö–õ/–í–´–ö–õ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ =====
@router.message(F.text.lower().contains("üì°"))
async def tracking_toggle(m: Message):
    lang = await get_user_lang(m.from_user.id)

    if await has_active_subscription(m.from_user.id):
        # –≤—ã–∫–ª—é—á–∞–µ–º —Ç—Ä–µ–∫–∏–Ω–≥
        assert pool is not None
        async with pool.acquire() as con:
            await con.execute("UPDATE subscriptions SET is_active=false WHERE tg_user_id=$1", m.from_user.id)
        await m.answer(L(lang, "tracking_off"), reply_markup=start_kb(lang, False))
        return

    # –≤–∫–ª—é—á–∞–µ–º —Ç—Ä–µ–∫–∏–Ω–≥
    if m.from_user.id not in last_loc:
        await m.answer(L(lang, "send_location_first"), reply_markup=location_request_kb(lang))
        return

    await m.answer(L(lang, "pick_tracking_radius"), reply_markup=track_radius_kb())

# –í—ã–±–æ—Ä —Ä–∞–¥–∏—É—Å–∞ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
@router.callback_query(F.data.startswith("track:"))
async def on_track_radius(cq: CallbackQuery):
    uid = cq.from_user.id
    lang = await get_user_lang(uid)

    if uid not in last_loc:
        await cq.message.answer(L(lang, "send_location_first"), reply_markup=location_request_kb(lang))
        await cq.answer(); return

    miles = int(cq.data.split(":")[1])
    r_m = miles_to_meters(miles)
    lat, lon, _ = last_loc[uid]

    assert pool is not None
    async with pool.acquire() as con:
        await con.execute("DELETE FROM subscriptions WHERE tg_user_id=$1", uid)
        await con.execute(
            """
            INSERT INTO subscriptions(tg_user_id, center, radius_m, is_active, last_refreshed_at)
            VALUES ($1, ST_MakePoint($2,$3)::geography, $4, TRUE, NOW())
            """,
            uid, float(lon), float(lat), float(r_m)
        )

    await cq.message.answer(f"{L(lang,'tracking_on')} ‚Ä¢ {miles} mi")
    try:
        await bot.send_message(uid, L(lang, "tracking_on"), reply_markup=start_kb(lang, True))
    except Exception:
        pass
    await cq.answer(); return

# ===== –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å—Ç–∞—Ä–æ–≥–æ 'sub:' =====
@router.callback_query(F.data.startswith("sub:"))
async def sub_pick_radius_compat(cq: CallbackQuery):
    miles = cq.data.split(":")[1]
    cq.data = f"track:{miles}"
    return await on_track_radius(cq)

@router.message(F.text.lower() == "/mysub")
async def my_sub(m: Message):
    assert pool is not None
    async with pool.acquire() as con:
        await con.execute(
            """
            UPDATE subscriptions
            SET is_active=false
            WHERE is_active
              AND last_refreshed_at < NOW() - INTERVAL '30 days'
        """
        )
        rows = await con.fetch(
            """
            SELECT id, ST_Y(center::geometry) lat, ST_X(center::geometry) lon,
                   radius_m, is_active, created_at, last_refreshed_at
            FROM subscriptions WHERE tg_user_id=$1
            ORDER BY created_at DESC
        """, m.from_user.id)
    if not rows:
        await m.answer("–ü–æ–¥–ø–∏—Å–æ–∫ –Ω–µ—Ç. –ù–∞–∂–º–∏ ¬´üì° –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ¬ª.")
        return
    out = []
    for r in rows:
        status = '–≤–∫–ª' if r['is_active'] else '–≤—ã–∫–ª'
        out.append(f"#{r['id']} ‚Ä¢ {r['radius_m']/1609.344:.0f} mi ‚Ä¢ {status} ‚Ä¢ –æ–±–Ω–æ–≤–ª–µ–Ω–æ: {fmt_ts(r['last_refreshed_at'])}")
    await m.answer("\n".join(out))

@router.message(F.text.lower() == "/unsubscribe")
async def unsubscribe(m: Message):
    assert pool is not None
    async with pool.acquire() as con:
        await con.execute("UPDATE subscriptions SET is_active=false WHERE tg_user_id=$1", m.from_user.id)
    lang = await get_user_lang(m.from_user.id)
    await m.answer(L(lang, "tracking_off"))

async def notify_subscribers(
    poi_id: int,
    lat: float, lon: float,
    category: str,
    description: Optional[str],
    created_at: datetime,
    photos: Optional[List[str]] = None,
    exclude_tg_id: Optional[int] = None
):
    assert pool is not None
    async with pool.acquire() as con:
        # –ª–µ–Ω–∏–≤–æ –≤—ã–∫–ª—é—á–∞–µ–º –æ—á–µ–Ω—å —Å—Ç–∞—Ä—ã–µ (30d)
        await con.execute(
            """
            UPDATE subscriptions
            SET is_active=false
            WHERE is_active
              AND last_refreshed_at < NOW() - INTERVAL '30 days'
        """
        )
        sub_rows = await con.fetch(
            """
            SELECT DISTINCT tg_user_id
            FROM subscriptions
            WHERE is_active
              AND last_refreshed_at >= NOW() - INTERVAL '30 days'
              AND ST_DWithin(center, ST_MakePoint($1,$2)::geography, radius_m)
            """,
            float(lon), float(lat)
        )
        if photos is None:
            photos = await con.fetchval(
                """
                SELECT array_agg(file_id ORDER BY created_at)
                FROM poi_photo WHERE poi_id=$1
                """,
                poi_id
            ) or []

    if not sub_rows:
        return

    gmaps = f"https://www.google.com/maps/search/?api=1&query={lat},{lon}"

    for r in sub_rows:
        tgid = int(r["tg_user_id"])
        if exclude_tg_id and tgid == exclude_tg_id:
            continue
        try:
            user_lang = await get_user_lang(tgid)
            header = f"üîî –ù–æ–≤–∞—è —Ç–æ—á–∫–∞ —Ä—è–¥–æ–º #{poi_id}\n<b>{category}</b>\n"
            if description:
                header += f"{description}\n"
            caption = (
                header +
                f"‚è± {L(user_lang,'added_label')}: <b>{fmt_ts(created_at)}</b>\n" +
                f"<a href='{gmaps}'>{L(user_lang,'open_in_map')}</a> ‚Ä¢ ({L(user_lang,'confirm_button')})"
            )

            if photos:
                medias: List[InputMediaPhoto] = []
                for i, fid in enumerate(photos[:10]):
                    if i == 0:
                        medias.append(InputMediaPhoto(media=fid, caption=caption, parse_mode=ParseMode.HTML))
                    else:
                        medias.append(InputMediaPhoto(media=fid))
                await bot.send_media_group(chat_id=tgid, media=medias)
                await bot.send_message(
                    chat_id=tgid,
                    text=L(user_lang, "press_to_confirm"),
                    reply_markup=confirm_kb(poi_id, user_lang)
                )
            else:
                await bot.send_message(tgid, caption, disable_web_page_preview=True,
                                       reply_markup=confirm_kb(poi_id, user_lang))
        except Exception:
            continue

# ===== –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ =====
@router.message(F.text.startswith("/confirm_"))
async def confirm_cmd(m: Message):
    try:
        poi_id = int(m.text.split("_", 1)[1])
    except Exception:
        await m.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã. –ü—Ä–∏–º–µ—Ä: /confirm_123")
        return
    await _do_confirm(user_id=m.from_user.id, username=m.from_user.username, poi_id=poi_id, reply_to=m)

@router.callback_query(F.data.startswith("cf:"))
async def confirm_cb(cq: CallbackQuery):
    try:
        poi_id = int(cq.data.split(":")[1])
    except Exception:
        lang = await get_user_lang(cq.from_user.id)
        await cq.answer(L(lang, "wrong_button"))
        return
    lang = await get_user_lang(cq.from_user.id)
    await cq.answer(L(lang, "checking"))
    await _do_confirm(user_id=cq.from_user.id, username=cq.from_user.username, poi_id=poi_id, reply_to=cq.message)

async def _do_confirm(user_id: int, username: Optional[str], poi_id: int, reply_to: Message):
    lang = await get_user_lang(user_id)
    if not is_location_fresh(user_id):
        await reply_to.answer(
            L(lang, "need_fresh_loc", mins=FRESH_LOCATION_MINUTES),
            reply_markup=location_request_kb(lang)
        )
        return

    user_lat, user_lon, _ = last_loc[user_id]
    user_row_id = await ensure_user(user_id, username)

    assert pool is not None
    async with pool.acquire() as con:
        poi = await con.fetchrow(
            """
            SELECT p.id, p.category, p.description, p.created_by,
                   ST_Y(p.geom::geometry) AS lat,
                   ST_X(p.geom::geometry) AS lon,
                   ST_Distance(p.geom, ST_MakePoint($1,$2)::geography) AS dist_m,
                   COALESCE(
                       (SELECT MAX(pc.created_at) FROM poi_confirmation pc WHERE pc.poi_id = p.id),
                       p.created_at
                   ) AS last_ts
            FROM poi p
            WHERE p.id = $3
            """,
            float(user_lon), float(user_lat), poi_id
        )

    if not poi:
        await reply_to.answer(L(lang, "point_not_found"))
        return

    last_ts: datetime = poi["last_ts"]
    if last_ts is None or (datetime.now(timezone.utc) - last_ts).total_seconds() > 12 * 3600:
        await reply_to.answer(L(lang, "point_outdated"))
        return

    if poi["created_by"] == user_row_id:
        await reply_to.answer(L(lang, "cant_confirm_own"))
        return

    max_m = miles_to_meters(CONFIRM_RADIUS_MI)
    if float(poi["dist_m"]) > max_m:
        await reply_to.answer(L(lang, "too_far_to_confirm"))
        return

    assert pool is not None
    async with pool.acquire() as con:
        await con.execute(
            "INSERT INTO poi_confirmation(poi_id, user_id) VALUES ($1,$2) ON CONFLICT (poi_id, user_id) DO NOTHING",
            poi_id, user_row_id
        )
        cnt = await con.fetchval("SELECT COUNT(*) FROM poi_confirmation WHERE poi_id=$1", poi_id)

    await reply_to.answer(
        f"{L(lang,'confirmed_title')}: <b>{poi['category']}</b>\n"
        f"{L(lang,'total_confirmations')}: <b>{cnt}</b>"
    )

# ===== –§–æ–ª–±—ç–∫ =====
@router.message(F.text)
async def fallback(m: Message):
    lang = await get_user_lang(m.from_user.id)
    await m.answer(
        "üìç " + L(lang, "send_location_first"),
        reply_markup=start_kb(lang, await has_active_subscription(m.from_user.id))
    )

# ========= MAIN =========
def main():
    dp.run_polling(bot)

if __name__ == "__main__":
    main()
